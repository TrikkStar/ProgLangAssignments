#reader(lib"read.ss""wxme")WXME0108 ## 
#|
   This file uses the GRacket editor format.
   Open this file in DrRacket version 6.4 or later to read it.

   Most likely, it was created by saving a program in DrRacket,
   and it probably contains a program with non-text elements
   (such as images or comment boxes).

            http://racket-lang.org/
|#
 32 7 #"wxtext\0"
3 1 6 #"wxtab\0"
1 1 8 #"wximage\0"
2 0 8 #"wxmedia\0"
4 1 34 #"(lib \"syntax-browser.ss\" \"mrlib\")\0"
1 0 16 #"drscheme:number\0"
3 0 44 #"(lib \"number-snip.ss\" \"drscheme\" \"private\")\0"
1 0 36 #"(lib \"comment-snip.ss\" \"framework\")\0"
1 0 93
(
 #"((lib \"collapsed-snipclass.ss\" \"framework\") (lib \"collapsed-sni"
 #"pclass-wxme.ss\" \"framework\"))\0"
) 0 0 43 #"(lib \"collapsed-snipclass.ss\" \"framework\")\0"
0 0 19 #"drscheme:sexp-snip\0"
0 0 36 #"(lib \"cache-image-snip.ss\" \"mrlib\")\0"
1 0 68
(
 #"((lib \"image-core.ss\" \"mrlib\") (lib \"image-core-wxme.rkt\" \"mr"
 #"lib\"))\0"
) 1 0 29 #"drscheme:bindings-snipclass%\0"
1 0 101
(
 #"((lib \"ellipsis-snip.rkt\" \"drracket\" \"private\") (lib \"ellipsi"
 #"s-snip-wxme.rkt\" \"drracket\" \"private\"))\0"
) 2 0 88
(
 #"((lib \"pict-snip.rkt\" \"drracket\" \"private\") (lib \"pict-snip.r"
 #"kt\" \"drracket\" \"private\"))\0"
) 0 0 34 #"(lib \"bullet-snip.rkt\" \"browser\")\0"
0 0 25 #"(lib \"matrix.ss\" \"htdp\")\0"
1 0 22 #"drscheme:lambda-snip%\0"
1 0 29 #"drclickable-string-snipclass\0"
0 0 26 #"drracket:spacer-snipclass\0"
0 0 57
#"(lib \"hrule-snip.rkt\" \"macro-debugger\" \"syntax-browser\")\0"
1 0 26 #"drscheme:pict-value-snip%\0"
0 0 45 #"(lib \"image-snipr.ss\" \"slideshow\" \"private\")\0"
1 0 38 #"(lib \"pict-snipclass.ss\" \"slideshow\")\0"
2 0 55 #"(lib \"vertical-separator-snip.ss\" \"stepper\" \"private\")\0"
1 0 18 #"drscheme:xml-snip\0"
1 0 31 #"(lib \"xml-snipclass.ss\" \"xml\")\0"
1 0 21 #"drscheme:scheme-snip\0"
2 0 34 #"(lib \"scheme-snipclass.ss\" \"xml\")\0"
1 0 10 #"text-box%\0"
1 0 32 #"(lib \"text-snipclass.ss\" \"xml\")\0"
1 0 1 6 #"wxloc\0"
          0 0 55 0 1 #"\0"
0 75 1 #"\0"
0 10 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 0 9
#"Standard\0"
0 75 12 #"Courier New\0"
0 10 90 -1 90 -1 3 -1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 255 255 255 1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1 1 1 1 1 1 0 0 0 0 0 0 -1 -1 2 24
#"framework:default-color\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 255 255 255 -1 -1 2
1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 15
#"text:ports out\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 150 0 150 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 93 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 255 0 0 0 0 0 -1
-1 2 15 #"text:ports err\0"
0 -1 1 #"\0"
1 0 -1 -1 93 -1 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 17
#"text:ports value\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 175 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 27 #"Matching Parenthesis Style\0"
0 -1 1 #"\0"
1.0 0 92 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 34 139 34 0 0 0 -1
-1 2 1 #"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:symbol\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 38
#"framework:syntax-color:scheme:keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 38 38 128 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2
38 #"framework:syntax-color:scheme:comment\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 194 116 31 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 37
#"framework:syntax-color:scheme:string\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 35
#"framework:syntax-color:scheme:text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 39
#"framework:syntax-color:scheme:constant\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 41 128 38 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 49
#"framework:syntax-color:scheme:hash-colon-keyword\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 42
#"framework:syntax-color:scheme:parenthesis\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 132 60 36 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:error\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 36
#"framework:syntax-color:scheme:other\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 16
#"Misspelled Text\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2
38 #"drracket:check-syntax:lexically-bound\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 81 112 203 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 28
#"drracket:check-syntax:set!d\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 37
#"drracket:check-syntax:unused-require\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 36
#"drracket:check-syntax:free-variable\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 255 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 31
#"drracket:check-syntax:imported\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 68 0 203 0 0 0 -1 -1 2 47
#"drracket:check-syntax:my-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 178 34 34 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 50
#"drracket:check-syntax:their-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 116 0 0 0 0 -1 -1 2 48
#"drracket:check-syntax:unk-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
49 #"drracket:check-syntax:both-obligation-style-pref\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 139 142 28 0 0 0 -1 -1 2
26 #"plt:htdp:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 1
#"\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 2 27
#"plt:htdp:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 4 #"XML\0"
0 70 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 2 37 #"plt:module-language:test-coverage-on\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 -1 -1 2 38
#"plt:module-language:test-coverage-off\0"
0 -1 1 #"\0"
1 0 -1 -1 -1 93 -1 -1 0 1 0 0 0 1 0 0 0 0 0 0 255 165 0 0 0 0 -1 -1 4 1
#"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 1.0 1.0 1.0 1.0 1.0 1.0 0 0 0 0 0 0
-1 -1 4 1 #"\0"
0 -1 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 1 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 0 255 0 0 0 -1
-1 4 1 #"\0"
0 71 1 #"\0"
1.0 0 -1 -1 -1 -1 -1 -1 0 0 0 0 0 0 0 0 0 1.0 1.0 1.0 0 100 0 0 0 0 -1
-1           0 2190 0 28 3 12 #"#lang racket"
0 0 24 29 1 #"\n"
0 0 17 3 39 #";; Programming Languages, Assignment 10"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 107
(
 #";; In this assignment we will build an interpreter in Racket. This w"
 #"ill be a bit different from what we did"
) 0 0 24 29 1 #"\n"
0 0 17 3 12 #";; in OCAML:"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 33 #";; - There will be no parser step"
0 0 24 29 1 #"\n"
0 0 17 3 52 #";; - The language constructs are defined via structs"
0 0 24 29 1 #"\n"
0 0 17 3 108
(
 #";; - Expressions in the source language are valid Racket expressions"
 #", written by directly using the structs."
) 0 0 24 29 1 #"\n"
0 0 17 3 105
(
 #";; - Desugaring can be thought of as Racket functions or macros that"
 #" produce source language expressions."
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";; Most functions are provided default mock implementations. You wil"
 #"l need to"
) 0 0 24 29 1 #"\n"
0 0 17 3 16 #";; correct them."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; Unlike previous assignment, you should feel free to search throug"
 #"h the"
) 0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; Racket documentation if you need a specific function we have not "
 #"seen"
) 0 0 24 29 1 #"\n"
0 0 17 3 66
#";; yet. But don't overdo it, there aren't many functions you need."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; The things you need to implement have the word TODO in front of t"
 #"hem."
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 14 3 7 #"provide"
0 0 24 3 2 #" ("
0 0 14 3 15 #"all-defined-out"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 25 #";;           ENVIRONMENTS"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; We start by defining environments. Bindings are a struct, so we g"
 #"et "
) 0 0 24 29 1 #"\n"
0 0 17 3 53 #";; functions: binding, binding?, binding-s, binding-v"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 7 #"binding"
0 0 24 3 2 #" ("
0 0 14 3 1 #"s"
0 0 24 3 1 #" "
0 0 14 3 1 #"v"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 53 #";; An environment will be a list of \"binding\" structs"
0 0 24 29 1 #"\n"
0 0 17 3 37 #";; We start with an empty environment"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"empty"
0 0 24 3 1 #" "
0 0 14 3 4 #"null"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; TODO: Implement the function bind, which is given a symbol and a "
 #"value"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; and an environment and it returns a new environment where a new b"
 #"inding"
) 0 0 24 29 1 #"\n"
0 0 17 3 58
#";; has been added to the front of the list binding s to v."
0 0 24 29 1 #"\n"
0 0 17 3 48 #";; This should be a simple consing of a binding."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 4 #"bind"
0 0 24 3 1 #" "
0 0 14 3 1 #"s"
0 0 24 3 1 #" "
0 0 14 3 1 #"v"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 14 3 5 #"list*"
0 0 24 3 2 #" ("
0 0 14 3 7 #"binding"
0 0 24 3 1 #" "
0 0 14 3 1 #"s"
0 0 24 3 1 #" "
0 0 14 3 1 #"v"
0 0 24 3 2 #") "
0 0 14 3 3 #"env"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; TODO: Implement the function lookup, that looks for the symbol s "
 #"in"
) 0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; the structs contained in the list env, and returns the correspond"
 #"ing "
) 0 0 24 29 1 #"\n"
0 0 17 3 33 #";; value v stored in the binding."
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; It should throw an appropriate \"lookup failed\" error if it can'"
 #"t find"
) 0 0 24 29 1 #"\n"
0 0 17 3 14 #";; the symbol."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 6 #"lookup"
0 0 24 3 1 #" "
0 0 14 3 1 #"s"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 4 #"cond"
0 0 24 3 3 #" [("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 9 #"binding-s"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 3 #")) "
0 0 14 3 1 #"s"
0 0 24 3 3 #") ("
0 0 14 3 9 #"binding-v"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 3 #"not"
0 0 24 3 2 #" ("
0 0 14 3 6 #"equal?"
0 0 24 3 1 #" "
0 0 14 3 4 #"null"
0 0 24 3 2 #" ("
0 0 14 3 3 #"car"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 5 #"))) ("
0 0 14 3 6 #"lookup"
0 0 24 3 1 #" "
0 0 14 3 1 #"s"
0 0 24 3 2 #" ("
0 0 14 3 3 #"cdr"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"        ["
0 0 14 3 4 #"else"
0 0 24 3 2 #" ("
0 0 14 3 5 #"error"
0 0 24 3 2 #" ("
0 0 14 3 13 #"string-append"
0 0 24 3 1 #" "
0 0 19 3 30 #"\"lookup: symbol not defined: \""
0 0 24 29 1 #"\n"
0 0 24 3 25 #"                        ("
0 0 14 3 14 #"symbol->string"
0 0 24 3 1 #" "
0 0 14 3 1 #"s"
0 0 24 3 6 #")))]))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 26 #";;            THE LANGUAGE"
0 0 24 29 1 #"\n"
0 0 17 3 46 #";; We define the language in terms of structs."
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; We will treat the bool and num structs as both expressions and va"
 #"lues"
) 0 0 24 29 1 #"\n"
0 0 17 3 76
(
 #";; So your interpreter should be producing num or bool structs (or c"
 #"losures)"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 3 #"var"
0 0 24 3 2 #" ("
0 0 14 3 1 #"s"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 3 #"num"
0 0 24 3 2 #" ("
0 0 14 3 1 #"n"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 4 #"bool"
0 0 24 3 2 #" ("
0 0 14 3 1 #"b"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 5 #"arith"
0 0 24 3 2 #" ("
0 0 14 3 2 #"op"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 5 #")    "
0 0 17 3 28 #"; arithmetic ops: +, -, *, /"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 4 #"comp"
0 0 24 3 2 #" ("
0 0 14 3 2 #"op"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 6 #")     "
0 0 17 3 30 #"; comparison ops: <, <=, >, >="
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 4 #"if-e"
0 0 24 3 2 #" ("
0 0 14 3 3 #"tst"
0 0 24 3 1 #" "
0 0 14 3 3 #"thn"
0 0 24 3 1 #" "
0 0 14 3 3 #"els"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 3 #")  "
0 0 17 3 13 #"; conditional"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 4 #"eq-e"
0 0 24 3 2 #" ("
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 11 #")          "
0 0 17 3 10 #"; equality"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 5 #"let-e"
0 0 24 3 2 #" ("
0 0 14 3 1 #"s"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 6 #")     "
0 0 17 3 18 #"; let s = e1 in e2"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 3 #"fun"
0 0 24 3 2 #" ("
0 0 14 3 4 #"name"
0 0 24 3 1 #" "
0 0 14 3 3 #"arg"
0 0 24 3 1 #" "
0 0 14 3 4 #"body"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 2 #") "
0 0 17 3 11 #"; functions"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 4 #"call"
0 0 24 3 2 #" ("
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 9 #")        "
0 0 17 3 15 #"; function call"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 3 #"nul"
0 0 24 3 4 #" () "
0 0 23 3 13 #"#:transparent"
0 0 24 3 15 #")              "
0 0 17 3 6 #"; null"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 5 #"isnul"
0 0 24 3 2 #" ("
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 12 #")           "
0 0 17 3 7 #"; null?"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 6 #"pair-e"
0 0 24 3 2 #" ("
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 7 #")      "
0 0 17 3 16 #"; pair/cons-cell"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 3 #"fst"
0 0 24 3 2 #" ("
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 14 #")             "
0 0 17 3 5 #"; car"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 3 #"snd"
0 0 24 3 2 #" ("
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 23 3 13 #"#:transparent"
0 0 24 3 14 #")             "
0 0 17 3 5 #"; cdr"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; The closures are not something that should show up on user progra"
 #"ms"
) 0 0 24 29 1 #"\n"
0 0 17 3 62
#";; But it's a kind of value produced by interpreting programs."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"struct"
0 0 24 3 1 #" "
0 0 14 3 4 #"clos"
0 0 24 3 2 #" ("
0 0 14 3 1 #"f"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 23 #"))                     "
0 0 17 3 30 #"; closure function environment"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 65
#";; TODO: Write a function \"valid-program?\" that takes as input an"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; expression e and returns a Racket boolean on whether that express"
 #"ion"
) 0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; is a syntactically valid program. This is the analog of our progr"
 #"am"
) 0 0 24 29 1 #"\n"
0 0 17 3 22 #";; passing the parser."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 38 #";; The syntax rules are the following:"
0 0 24 29 1 #"\n"
0 0 17 3 3 #";; "
0 0 24 29 1 #"\n"
0 0 17 3 62
#";; - A `var` is valid if `s` is a Racket symbol. Use `symbol?`"
0 0 24 29 1 #"\n"
0 0 17 3 62
#";; - A `num` is valid if `n` is a Racket number. Use `number?`"
0 0 24 29 1 #"\n"
0 0 17 3 66
#";; - A `bool` is valid if `b` is a Racket boolean`. Use `boolean?`"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";; - A `arith` is valid if `op` is from the list '+, '-, '*, '/ and"
0 0 24 29 1 #"\n"
0 0 17 3 56 #";;     the `e1` and `e2` components are themselves valid"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";; - A `comp` is valid if `op` is from the list '<, '<=, '>=, '> and"
0 0 24 29 1 #"\n"
0 0 17 3 56 #";;     the `e1` and `e2` components are themselves valid"
0 0 24 29 1 #"\n"
0 0 17 3 62
#";; - A `if-e` is valid if `tst`, `thn` and `els` are all valid"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";; - A `eq-e` is valid if both `e1` and `e2` are valid"
0 0 24 29 1 #"\n"
0 0 17 3 64
#";; - A `let-e` is valid if the `s` is an Racket symbol, and the "
0 0 24 29 1 #"\n"
0 0 17 3 41 #";;     `e1` and `e2` are themselves valid"
0 0 24 29 1 #"\n"
0 0 17 3 64
#";; - A `fun` is valid if `arg` is a Racket symbol, and `name` is"
0 0 24 29 1 #"\n"
0 0 17 3 65
#";;      either #f or a Racket symbol distinct from `arg`, and the"
0 0 24 29 1 #"\n"
0 0 17 3 67
#";;      `body` is valid. `name` is used for recursively calling the"
0 0 24 29 1 #"\n"
0 0 17 3 34 #";;      function, if it is not #f."
0 0 24 29 1 #"\n"
0 0 17 3 54 #";; - A `call` is valid if both `e1` and `e2` are valid"
0 0 24 29 1 #"\n"
0 0 17 3 21 #";; - A `nul` is valid"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";; - A `isnul` is valid if the `e` is valid"
0 0 24 29 1 #"\n"
0 0 17 3 56 #";; - A `pair-e` is valid if both `e1` and `e2` are valid"
0 0 24 29 1 #"\n"
0 0 17 3 37 #";; - A `fst` is valid if `e` is valid"
0 0 24 29 1 #"\n"
0 0 17 3 37 #";; - A `snd` is valid if `e` is valid"
0 0 24 29 1 #"\n"
0 0 17 3 47 #";; - Nothing else is valid (including closures)"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 48 #";; The arith case is done for you as an example."
0 0 24 29 1 #"\n"
0 0 17 3 52 #";; You will need to add many more cases to the cond."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 4 #"cond"
0 0 24 3 3 #" [("
0 0 14 3 6 #"arith?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 4 #"memq"
0 0 24 3 2 #" ("
0 0 14 3 8 #"arith-op"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"/"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"arith-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"arith-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"var?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 7 #"symbol?"
0 0 24 3 1 #" "
0 0 14 3 5 #"var-s"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"num?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 7 #"number?"
0 0 24 3 2 #" ("
0 0 14 3 5 #"num-n"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"bool?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 8 #"boolean?"
0 0 24 3 2 #" ("
0 0 14 3 6 #"bool-b"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"comp?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 4 #"memq"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-op"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 4 #"list"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"<"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 2 #"<="
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 2 #">="
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #">"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"if-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"if-e-tst"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"if-e-thn"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"if-e-els"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"eq-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"eq-e-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"eq-e-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 6 #"let-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 7 #"symbol?"
0 0 24 3 1 #" "
0 0 14 3 7 #"let-e-s"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"let-e-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"let-e-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"fun?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 7 #"symbol?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"fun-arg"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 2 #"or"
0 0 24 3 2 #" ("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"fun-name"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 21 3 2 #"#f"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 19 #"                  ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 7 #"symbol?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"fun-name"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 24 #"                       ("
0 0 14 3 3 #"not"
0 0 24 3 2 #" ("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"fun-name"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 7 #"fun-arg"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #"))))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"fun-body"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 5 #"))))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"call?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"call-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"call-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"nul?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 21 3 2 #"#t"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 6 #"isnul?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"isnul-e"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 7 #"pair-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 9 #"pair-e-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 9 #"pair-e-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"fst?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 5 #"fst-e"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"snd?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 14 #"valid-program?"
0 0 24 3 2 #" ("
0 0 14 3 5 #"snd-e"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"        ["
0 0 14 3 4 #"else"
0 0 24 3 1 #" "
0 0 21 3 2 #"#f"
0 0 24 3 3 #"]))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 13 #";;     VALUES"
0 0 24 29 1 #"\n"
0 0 17 3 51 #";; We will use some of the structs above as values."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; TODO: Implement the function `value?` that returns if the express"
 #"ion"
) 0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; is a value. You do not need to worry about checking syntax errors"
 #" at"
) 0 0 24 29 1 #"\n"
0 0 17 3 52 #";; this point. The rules for what is a value follow:"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";; - A `num` is a value"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";; - A `bool` is a value"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";; - A `nul` is a value"
0 0 24 29 1 #"\n"
0 0 17 3 24 #";; - A `clos` is a value"
0 0 24 29 1 #"\n"
0 0 17 3 64
#";; - A `pair-e` is a value only if both `e1` and `e2` are values"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; Do this as a big \"or\". The first step is done for you, you need"
 #" to"
) 0 0 24 29 1 #"\n"
0 0 17 3 16 #";; add the rest."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 6 #"value?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 14 3 2 #"or"
0 0 24 3 2 #" ("
0 0 14 3 4 #"num?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 5 #"bool?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 4 #"nul?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 5 #"clos?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 7 #"      ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 7 #"pair-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 12 #"           ("
0 0 14 3 6 #"value?"
0 0 24 3 2 #" ("
0 0 14 3 9 #"pair-e-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 12 #"           ("
0 0 14 3 6 #"value?"
0 0 24 3 2 #" ("
0 0 14 3 9 #"pair-e-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 5 #")))))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; TODO: Write a function `value-eq?` to test if two values are \"eq"
 #"ual\"."
) 0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; Two values `v1`, `v2` are considered equal in the following cases"
 #":"
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; - They are both `num`s and the corresponding Racket numbers are e"
 #"qual."
) 0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; - They are both `bool`s and the corresponding Racket bools are eq"
 #"ual."
) 0 0 24 29 1 #"\n"
0 0 17 3 26 #";; - They are both `nul`s."
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; - They are both `pair`s and their corresponding components are eq"
 #"ual."
) 0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; - Nothing else is equal (e.g. two closures cannot equal each othe"
 #"r)"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 9 #"value-eq?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 4 #"cond"
0 0 24 3 3 #" [("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 4 #"num?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 4 #"num?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 5 #"num-n"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 5 #"num-n"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 5 #"bool?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 5 #"bool?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 6 #"bool-b"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 6 #"bool-b"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 4 #"nul?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 4 #"nul?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 3 #")) "
0 0 21 3 2 #"#t"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 7 #"pair-e?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 7 #"pair-e?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"         ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 9 #"pair-e-e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 9 #"pair-e-e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 15 #"              ("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 9 #"pair-e-e2"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 9 #"pair-e-e2"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"        ["
0 0 14 3 4 #"else"
0 0 24 3 1 #" "
0 0 21 3 2 #"#f"
0 0 24 3 3 #"]))"
0 0 24 29 1 #"\n"
0 0 24 3 14 #"              "
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 23 #";;       INTERPRETATION"
0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; We will now implement the interpreter. You may assume that what y"
 #"ou are"
) 0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; given is a valid-program (no \"syntax errors\"). You will still n"
 #"eed to"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; throw \"implementation errors\" if you are for instance asked to "
 #"pick the"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; `fst` of something that is not a `pair-e`. The rules for interpre"
 #"tation"
) 0 0 24 29 1 #"\n"
0 0 17 3 18 #";; are as follows:"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 55 #";; - `num`, and `bool` and `nul` evaluate to themselves"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; - You do not need to check for a `clos` value as it's not allowed"
 #" to"
) 0 0 24 29 1 #"\n"
0 0 17 3 34 #";;     be part of a valid program."
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; - A `var` needs to look the symbol up in the environment that is "
 #"the"
) 0 0 24 29 1 #"\n"
0 0 17 3 43 #";;     argument to the interpreter function"
0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #";; - A `arith` needs to perform the correct operation based on the o"
 #"perator"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";;     to the results of recursively interpreting e1, e2. It should "
 #"throw"
) 0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";;     an error if the e1, e2 don't evaluate to `num`s. This case is"
 #" "
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";;     provided for you. Note how we return a `num`, not a Racket nu"
 #"mber."
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; - A `comp` needs to perform the correct operation based on the op"
 #"erator"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";;     to the results of recursively interpreting e1, e2. It should "
 #"throw"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";;     an error if the `e1, e2 don't evaluate to `num`s. You should "
 #"return"
) 0 0 24 29 1 #"\n"
0 0 17 3 16 #";;     a `bool`."
0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; - A `if-e` needs to first evaluate the `tst`. Throw an error if t"
 #"hat is"
) 0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";;     not a bool. Otherwise evaluate the appropriate `thn` or `els`"
 #" depending"
) 0 0 24 29 1 #"\n"
0 0 17 3 27 #";;     on the bool's value."
0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";; - A `eq-e` needs to evaluate the two expressions and test them fo"
 #"r equality"
) 0 0 24 29 1 #"\n"
0 0 17 3 24 #";;     using `value-eq?`"
0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";; - A `let-e` needs to evaluate `e1` in the current environment, th"
 #"en extend"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";;     the current environment by binding the symbol s to that value"
 #", and"
) 0 0 24 29 1 #"\n"
0 0 17 3 50 #";;     evaluate `e2` in this extended environment."
0 0 24 29 1 #"\n"
0 0 17 3 38 #";; - A `fun` needs to create a `clos`."
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; - A `call` needs to evaluate `e1` and `e2`. Throw an error if `e1"
 #"`"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";;     did not evaluate to a `clos`. If it did evaluate to a `clos`,"
 #" then"
) 0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";;     you must perform that function call correctly, interpreting t"
 #"he"
) 0 0 24 29 1 #"\n"
0 0 17 3 64
#";;     closure's function's body in the appropriate environment."
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";;     Note that one of the components of a `fun` element is `name`."
 #" "
) 0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";;     If it is set to #f then you can ignore it. But if it is not, "
 #"then"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";;     it is meant to be the name that the function can use to recur"
 #"sively"
) 0 0 24 29 1 #"\n"
0 0 17 3 77
(
 #";;     call itself, so you need to bind it to the closure before you"
 #" evaluate"
) 0 0 24 29 1 #"\n"
0 0 17 3 16 #";;     the body."
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";;     This is probably the most complicated part of the interpreter"
 #"."
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; - A `isnul` needs to evaluate the expression it contains, and ret"
 #"urns a"
) 0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";;     `bool` depending on whether that expression evaluated to `nul"
 #"`."
) 0 0 24 29 1 #"\n"
0 0 17 3 82
(
 #";;     Make sure you understand the crucial difference between `isnu"
 #"l` and `nul?`."
) 0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";; - A `pair-e` evaluates to a `pair-e` containing the results of in"
 #"terpreting"
) 0 0 24 29 1 #"\n"
0 0 17 3 33 #";;     its components `e1`, `e2`."
0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; - A `fst` evaluates the expression it contains. Throw an error if"
 #" that"
) 0 0 24 29 1 #"\n"
0 0 17 3 78
(
 #";;     is not a `pair-e`. If it is a `pair-e` then return its first "
 #"component."
) 0 0 24 29 1 #"\n"
0 0 17 3 80
(
 #";; - A `snd` does the same as `fst`, but returning the second compon"
 #"ent instead."
) 0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 80
(
 #";; TODO: Write the function `interp` that takes an environment and a"
 #"n expression"
) 0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; and interprets the expression in the environment based on the abo"
 #"ve"
) 0 0 24 29 1 #"\n"
0 0 17 3 15 #";; description."
0 0 24 29 1 #"\n"
0 0 17 3 27 #";; Some cases done for you."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 4 #"cond"
0 0 24 3 3 #" [("
0 0 14 3 4 #"num?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 14 3 1 #"e"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 6 #"arith?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 15 3 3 #"let"
0 0 24 3 3 #" (["
0 0 14 3 2 #"v1"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 8 #"arith-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ["
0 0 14 3 2 #"v2"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 8 #"arith-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ["
0 0 14 3 2 #"op"
0 0 24 3 2 #" ("
0 0 15 3 4 #"case"
0 0 24 3 2 #" ("
0 0 14 3 8 #"arith-op"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 33 #"                                ["
0 0 21 3 1 #"'"
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 1 #"+"
0 0 24 3 3 #"] ["
0 0 21 3 1 #"'"
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 1 #"-"
0 0 24 3 3 #"] ["
0 0 21 3 1 #"'"
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 14 3 1 #"*"
0 0 24 3 3 #"] ["
0 0 21 3 1 #"'"
0 0 14 3 1 #"/"
0 0 24 3 1 #" "
0 0 14 3 1 #"/"
0 0 24 3 4 #"])])"
0 0 24 29 1 #"\n"
0 0 24 3 23 #"                      ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 4 #"num?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 4 #"num?"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 3 #"num"
0 0 24 3 2 #" ("
0 0 14 3 2 #"op"
0 0 24 3 2 #" ("
0 0 14 3 5 #"num-n"
0 0 24 3 1 #" "
0 0 14 3 2 #"v1"
0 0 24 3 3 #") ("
0 0 14 3 5 #"num-n"
0 0 24 3 1 #" "
0 0 14 3 2 #"v2"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 27 #"                          ("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 35 #"\"interp: arithmetic on non-numbers\""
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"bool?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 14 3 1 #"e"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"nul?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 14 3 1 #"e"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"var?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 6 #"lookup"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"comp?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 3 #"and"
0 0 24 3 2 #" ("
0 0 14 3 4 #"num?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 29 #"                            ("
0 0 14 3 4 #"num?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 24 #"                       ("
0 0 15 3 4 #"cond"
0 0 24 3 3 #" [("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-op"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 21 3 1 #"'"
0 0 14 3 1 #"<"
0 0 24 3 3 #") ("
0 0 14 3 1 #"<"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")) ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 31 #"                             [("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-op"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 21 3 1 #"'"
0 0 14 3 2 #"<="
0 0 24 3 3 #") ("
0 0 14 3 2 #"<="
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")) ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 31 #"                             [("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-op"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 21 3 1 #"'"
0 0 14 3 1 #">"
0 0 24 3 3 #") ("
0 0 14 3 1 #">"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")) ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 31 #"                             [("
0 0 14 3 6 #"equal?"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-op"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 21 3 1 #"'"
0 0 14 3 2 #">="
0 0 24 3 3 #") ("
0 0 14 3 2 #">="
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")) ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"comp-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 5 #")))])"
0 0 24 29 1 #"\n"
0 0 24 3 24 #"                       ("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 22 #"\"argument(s) not nums\""
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"if-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 5 #"bool?"
0 0 24 3 2 #" ("
0 0 14 3 8 #"if-e-tst"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 24 #"                       ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 8 #"if-e-tst"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 28 #"                           ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 8 #"if-e-thn"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 28 #"                           ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 8 #"if-e-els"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 24 #"                       ("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 21 #"\"argument not a bool\""
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"eq-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 9 #"value-eq?"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"eq-e-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")) ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"eq-e-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 4 #")))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 6 #"let-e?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 6 #"interp"
0 0 24 3 2 #" ("
0 0 14 3 4 #"bind"
0 0 24 3 2 #" ("
0 0 14 3 7 #"let-e-s"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 35 #"                                  ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 8 #"let-e-e1"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 29 #"                            ("
0 0 14 3 8 #"let-e-e2"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 4 #"fun?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 4 #"clos"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 10 #"        [("
0 0 14 3 5 #"call?"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 5 #"clos?"
0 0 24 3 2 #" ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 3 #"env"
0 0 24 3 2 #" ("
0 0 14 3 7 #"call-e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 3 24 #"                       ("
0 0 14 3 2 #"if"
0 0 24 3 2 #" ("
0 0 14 3 3 #"not"
0 0 24 3 2 #" ("
0 0 14 3 5 #"equal"
0 0 24 3 1 #" "
0 0 21 3 2 #"#f"
0 0 24 3 2 #" ("
0 0 24 29 1 #"\n"
0 0 24 3 24 #"                       ("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 21 #"\"no function closure\""
0 0 24 3 3 #"))]"
0 0 24 29 1 #"\n"
0 0 24 3 9 #"        ["
0 0 14 3 4 #"else"
0 0 24 3 2 #" ("
0 0 14 3 5 #"error"
0 0 24 3 1 #" "
0 0 19 3 1 #"\""
0 0 19 3 7 #"interp:"
0 0 19 3 1 #" "
0 0 19 3 7 #"unknown"
0 0 19 3 11 #" expression"
0 0 19 3 1 #"\""
0 0 24 3 4 #")]))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 0 17 3 19 #";;         EVALUATE"
0 0 24 29 1 #"\n"
0 0 17 3 79
(
 #";; This method simply calls the interpreter with an initially empty "
 #"environment"
) 0 0 24 29 1 #"\n"
0 0 17 3 19 #";; Do not change it"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 8 #"evaluate"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 14 3 6 #"interp"
0 0 24 3 1 #" "
0 0 14 3 5 #"empty"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 43 #";;        DESUGARING   /   SURFACE LANGUAGE"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";; We will create Racket functions and macros that act as desugaring"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; These should not perform any evaluation/interpretation, they mere"
 #"ly"
) 0 0 24 29 1 #"\n"
0 0 17 3 4 #";; \""
0 0 17 3 7 #"rewrite"
0 0 17 3 5 #"\" a \""
0 0 17 3 7 #"program"
0 0 17 3 14 #"\" into a new \""
0 0 17 3 9 #"program\"."
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; As an example, here is a Racket function `not-e` that performs a "
 #"`not`:"
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 5 #"not-e"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 4 #"if-e"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #" ("
0 0 14 3 4 #"bool"
0 0 24 3 1 #" "
0 0 21 3 2 #"#f"
0 0 24 3 3 #") ("
0 0 14 3 4 #"bool"
0 0 24 3 1 #" "
0 0 21 3 2 #"#t"
0 0 24 3 3 #")))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 59
#";; Basic examples for operations. You can use them to write"
0 0 24 29 1 #"\n"
0 0 17 3 40 #";; source language programs for testing."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 5 #"plus2"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 5 #"arith"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"+"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 6 #"minus2"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 5 #"arith"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"-"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 5 #"mult2"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 5 #"arith"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"*"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 4 #"div2"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 5 #"arith"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"/"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 3 #"leq"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 4 #"comp"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 2 #"<="
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 2 #"le"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 4 #"comp"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"<"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 3 #"geq"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 4 #"comp"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 2 #">="
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 2 #"ge"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 3 #") ("
0 0 14 3 4 #"comp"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #">"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 2 #"))"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; TODO: Write a function `neq` that takes as input two source langu"
 #"age"
) 0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; expressions and returns the expression that tests that they are n"
 #"ot"
) 0 0 24 29 1 #"\n"
0 0 17 3 61
#";; equal. This should be a combination of `not-e` and `eq-e`."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 3 #"neq"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 21 3 2 #"#f"
0 0 24 3 7 #")      "
0 0 17 3 24 #"; <---- Need to fix this"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; TODO: Write a function `or2` that takes as input two source langu"
 #"age"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; expressions `e1` and `e2` and returns the appropriate `if-e` expr"
 #"ession"
) 0 0 24 29 1 #"\n"
0 0 17 3 22 #";; that performs the \""
0 0 17 3 27 #"or\" of the two expressions."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 3 #"or2"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 21 3 2 #"#f"
0 0 24 3 4 #")   "
0 0 17 3 26 #";  <----- Need to fix this"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; TODO: Write a function `and2` that takes as input two source lang"
 #"uage"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; expressions `e1` and `e2` and returns the appropriate `if-e` expr"
 #"ession"
) 0 0 24 29 1 #"\n"
0 0 17 3 22 #";; that performs the \""
0 0 17 3 28 #"and\" of the two expressions."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 2 #" ("
0 0 14 3 4 #"and2"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 2 #"  "
0 0 21 3 2 #"#f"
0 0 24 3 4 #")   "
0 0 17 3 26 #";  <----- Need to fix this"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; TODO: Write a function `or-e` that takes as input any number of s"
 #"ource"
) 0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; language expressions as input and creates the corresponding neste"
 #"d"
) 0 0 24 29 1 #"\n"
0 0 17 3 44 #";; `if-e` expression that behaves like the \""
0 0 17 3 25 #"or\" of those expressions."
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; If we define a function as `(lambda es body)`, i.e. no parenthese"
 #"s at"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; the second argument, then the function accepts any number of argu"
 #"ments"
) 0 0 24 29 1 #"\n"
0 0 17 3 64
#";; and puts them all in a list, named `es` in the above example."
0 0 24 29 1 #"\n"
0 0 17 3 67
#";; A call to `(or-e)` with no arguments would thus end up in a call"
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; where `es` is the null list. That call should be returning the fa"
 #"lse"
) 0 0 24 29 1 #"\n"
0 0 17 3 15 #";; bool struct."
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; You can do this with a call to `foldr`. Look at the documentation"
 #" to"
) 0 0 24 29 1 #"\n"
0 0 17 3 38 #";; learn about the syntax for `foldr`."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 4 #"or-e"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 1 #" "
0 0 14 3 2 #"es"
0 0 24 29 1 #"\n"
0 0 24 3 5 #"    ("
0 0 14 3 4 #"bool"
0 0 24 3 1 #" "
0 0 21 3 2 #"#f"
0 0 24 3 9 #")))      "
0 0 17 3 26 #"; <------ Need to fix this"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; TODO: We will similarly do something for `and-e`, but for this on"
 #"e"
) 0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; we will instead build a macro. For no arguments, this should retu"
 #"rn"
) 0 0 24 29 1 #"\n"
0 0 17 3 30 #";; the language bool for true."
0 0 24 29 1 #"\n"
0 0 17 3 39 #";; The two base cases are done for you."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 13 #"define-syntax"
0 0 24 3 1 #" "
0 0 14 3 5 #"and-e"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 12 #"syntax-rules"
0 0 24 3 3 #" ()"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"    [("
0 0 14 3 5 #"and-e"
0 0 24 3 3 #") ("
0 0 14 3 4 #"bool"
0 0 24 3 1 #" "
0 0 21 3 2 #"#t"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"    [("
0 0 14 3 5 #"and-e"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 2 #") "
0 0 14 3 2 #"e1"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"    [("
0 0 14 3 5 #"and-e"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e2"
0 0 24 3 1 #" "
0 0 14 3 3 #"..."
0 0 24 3 2 #") "
0 0 21 3 2 #"#f"
0 0 24 3 6 #"]))   "
0 0 17 3 38 #"; <-- Need to fix this. Use and2 and \""
0 0 17 3 10 #"recursion\""
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 54 #";; TODO: Build a `let-e*` macro that takes input like:"
0 0 24 29 1 #"\n"
0 0 17 3 72
(
 #";; `(let-e* ([s1 e1] [s2 e2] ...) e)` and creates the equivalent nes"
 #"ted "
) 0 0 24 29 1 #"\n"
0 0 17 3 22 #";; `let-e` expression."
0 0 24 29 1 #"\n"
0 0 17 3 39 #";; The two base cases are done for you."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 13 #"define-syntax"
0 0 24 3 1 #" "
0 0 14 3 6 #"let-e*"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 12 #"syntax-rules"
0 0 24 3 3 #" ()"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"    [("
0 0 14 3 6 #"let-e*"
0 0 24 3 4 #" () "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 14 3 1 #"e"
0 0 24 3 1 #"]"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"    [("
0 0 14 3 6 #"let-e*"
0 0 24 3 3 #" (["
0 0 14 3 2 #"s1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 3 #"]) "
0 0 14 3 1 #"e"
0 0 24 3 3 #") ("
0 0 14 3 5 #"let-e"
0 0 24 3 1 #" "
0 0 14 3 2 #"s1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 1 #" "
0 0 14 3 1 #"e"
0 0 24 3 2 #")]"
0 0 24 29 1 #"\n"
0 0 24 3 6 #"    [("
0 0 14 3 6 #"let-e*"
0 0 24 3 3 #" (["
0 0 14 3 2 #"s1"
0 0 24 3 1 #" "
0 0 14 3 2 #"e1"
0 0 24 3 2 #"] "
0 0 14 3 4 #"rest"
0 0 24 3 1 #" "
0 0 14 3 3 #"..."
0 0 24 3 2 #") "
0 0 14 3 1 #"e"
0 0 24 3 2 #") "
0 0 21 3 2 #"#f"
0 0 24 3 5 #"]))  "
0 0 17 3 23 #"; <-- Need to fix this."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; TODO: Write functions or macros `plus`, and `mult` that take any "
 #"number"
) 0 0 24 29 1 #"\n"
0 0 17 3 74
(
 #";; of source language expressions as arguments and creates a corresp"
 #"onding"
) 0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; nested `plus2` or `mult2` expression that computes the correspond"
 #"ing"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; sum or product. For zero arguments provided it should return the "
 #"`num`"
) 0 0 24 29 1 #"\n"
0 0 17 3 27 #";; for 0 or 1 respectively."
0 0 24 29 1 #"\n"
0 0 17 3 71
(
 #";; You can choose either a macro approach like in `and-e` or a funct"
 #"ion"
) 0 0 24 29 1 #"\n"
0 0 17 3 39 #";; approach and `foldr` like in `or-e`."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #";; TODO: Write a macro `minus` that takes one or more arguments and "
 #"behaves"
) 0 0 24 29 1 #"\n"
0 0 17 3 14 #";; as follows:"
0 0 24 29 1 #"\n"
0 0 17 3 82
(
 #";; - With one argument, it returns its negation (as a source languag"
 #"e expression)."
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; - With two or more arguments, it subtracts all the remaining argu"
 #"ments"
) 0 0 24 29 1 #"\n"
0 0 17 3 25 #";;    from the first one."
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; Try out the function `-` in Racket to see examples of the behavio"
 #"r."
) 0 0 24 29 1 #"\n"
0 0 17 3 42 #";; Do this as a macro, similar to `and-e`."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 19 #";;            LISTS"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; A source language list is, analogously to Racket's lists, a neste"
 #"d"
) 0 0 24 29 1 #"\n"
0 0 17 3 68
#";; sequence of `pair-e` expressions where the `fst` (car) components"
0 0 24 29 1 #"\n"
0 0 17 3 64
#";; contain the values and the `snd` (cdr) components contain the"
0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; tails of the list. The list terminates when the tail is the `nul`"
 #"."
) 0 0 24 29 1 #"\n"
0 0 17 3 65
#";; An example would be: `(pair-e (num 2) (pair-e (num 5) (nul)))`"
0 0 24 29 1 #"\n"
0 0 17 3 2 #";;"
0 0 24 29 1 #"\n"
0 0 17 3 70
(
 #";; TODO: Write a function `racketlist->sourcelist` that takes as inp"
 #"ut"
) 0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #";; a Racket list of (presumably source language) expressions and con"
 #"structs"
) 0 0 24 29 1 #"\n"
0 0 17 3 69
(
 #";; the corresponding source language list expression containing thos"
 #"e"
) 0 0 24 29 1 #"\n"
0 0 17 3 73
(
 #";; entries. For example `(racketlist->sourcelist (list (num 2) (num "
 #"5)))`"
) 0 0 24 29 1 #"\n"
0 0 17 3 45 #";; should return the example mentioned above."
0 0 24 29 1 #"\n"
0 0 17 3 43 #";; Do this as a function that uses `foldr`."
0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 22 #"racketlist->sourcelist"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 15 3 6 #"lambda"
0 0 24 3 2 #" ("
0 0 14 3 4 #"exps"
0 0 24 3 1 #")"
0 0 24 29 1 #"\n"
0 0 24 3 4 #"    "
0 0 21 3 2 #"#f"
0 0 24 3 10 #"))        "
0 0 17 3 52 #";  <--- Replace this with an appropriate foldr call."
0 0 24 29 1 #"\n"
0 0 24 29 1 #"\n"
0 0 17 3 68
#";; TODO: Write a source language expression `map-e`. It should be a "
0 0 24 29 1 #"\n"
0 0 17 3 32 #";; `fun` that takes as input a \""
0 0 17 3 39 #"fun\" `f` and returns a `fun` that takes"
0 0 24 29 1 #"\n"
0 0 17 3 57
#";; as input a source language list `lst` and performs a \""
0 0 17 3 11 #"map\" of the"
0 0 24 29 1 #"\n"
0 0 17 3 57 #";; function f on the list lst (when interpreted that is)."
0 0 24 29 1 #"\n"
0 0 17 3 75
(
 #";; The first few lines, that set up the curried function, are done f"
 #"or you."
) 0 0 24 29 1 #"\n"
0 0 24 3 1 #"("
0 0 15 3 6 #"define"
0 0 24 3 1 #" "
0 0 14 3 5 #"map-e"
0 0 24 29 1 #"\n"
0 0 24 3 3 #"  ("
0 0 14 3 3 #"fun"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 3 #"map"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 1 #"f"
0 0 24 3 1 #" "
0 0 24 29 1 #"\n"
0 0 24 3 8 #"       ("
0 0 14 3 3 #"fun"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 5 #"inner"
0 0 24 3 1 #" "
0 0 21 3 1 #"'"
0 0 14 3 3 #"lst"
0 0 24 29 1 #"\n"
0 0 24 3 13 #"            ("
0 0 14 3 3 #"nul"
0 0 24 3 7 #"))))   "
0 0 17 3 26 #"; <--- Need to change this"
0 0 24 29 1 #"\n"
0           0
